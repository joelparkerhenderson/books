# Exceptional Ruby

## Key Concepts

This focused guide explores the Ruby exception handling system with depth rarely found in general Ruby books, examining not just the mechanics of begin-rescue-end blocks but the philosophy behind writing robust, failure-resistant code. The book introduces exception safety levels borrowed from C++ development, teaching developers how to make guarantees about code behavior even when exceptions occur, from basic guarantees ensuring no resource leaks to strong guarantees maintaining invariants. Core topics include the Ruby exception hierarchy with StandardError as the default rescue target, the stack unwinding process during exception propagation, and advanced techniques like dynamic exception lists, exception matchers, and module tags for categorizing failures. The author emphasizes that exceptions should be exceptional, advocating for designing APIs that minimize exception usage in favor of explicit failure objects or no-raise patterns when appropriate.

## Who Should Read It and Why

This book serves Ruby developers who have moved beyond beginner tutorials and want to write production-quality code that gracefully handles failure cases rather than crashing unpredictably. Developers accustomed to defensive programming with excessive nil checks will discover how proper exception handling creates cleaner code paths while still protecting against edge cases. The content particularly benefits those building libraries or frameworks where robust error handling directly impacts user experience, offering guidance on when to raise exceptions versus returning error values, how to design exception hierarchies that clients can handle meaningfully, and techniques for testing exception safety guarantees. Anyone who has struggled with mysterious bugs caused by partial state updates during exception propagation will appreciate the systematic approach to reasoning about exception flow and ensuring cleanup code always executes.

## Practical Applications

Readers will learn to implement the else clause in rescue blocks for code that should only run when no exceptions occur, use ensure blocks correctly for guaranteed cleanup while avoiding common pitfalls like swallowing exceptions, and employ statement modifier rescue for concise one-liner error handling. The book demonstrates testing exception safety with custom testing harnesses that inject failures at every possible point, creating custom exception classes with meaningful hierarchies and informative messages, and using caller context to make exception backtraces more helpful. Developers will discover patterns for wrapping third-party libraries with domain-specific exceptions, implementing the Cond library's Common Lisp-style exception handling for more flexible error recovery, and designing no-raise APIs using result objects or Option types. Practical examples cover handling exceptions in threads where they don't propagate normally, managing Timeout::Error and other interrupt exceptions safely, and using refinements or module tags to classify exceptions by type of failure rather than origin.
