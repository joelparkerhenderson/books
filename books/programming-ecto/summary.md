# Programming Ecto

## Key Concepts

This book teaches using Ecto as Elixir's database library providing composable query API, schema definitions, and changesets for validation, enabling type-safe database interactions without sacrificing flexibility or performance. The core Ecto philosophy treats database access as pipeable operations composing small functions rather than string-based query building, with queries as data structures transformed through functions before execution. Key concepts include schemas defining Elixir structs mapping to database tables with type specifications, changesets providing data validation and type casting before database writes, and repositories encapsulating database connections and query execution. The book covers Ecto.Query DSL for building queries through from, where, select, and other macros creating readable database access, associations defining relationships between schemas like belongs_to and has_many, and migrations for evolving database schema over time tracked in version control. Advanced features include multi-tenancy through Ecto's prefix support, database transactions ensuring atomicity, and using fragments for database-specific features unavailable through standard query API.

## Who Should Read It and Why

This book targets Elixir developers building database-backed applications who need deeper understanding than Phoenix scaffolds provide, programmers familiar with ActiveRecord or other ORMs curious how Ecto's explicit approach differs philosophically, and teams maintaining complex data models needing advanced features like polymorphic associations or dynamic queries. Those struggling with Ecto errors because they conceptualize it like Rails ActiveRecord will discover that understanding Ecto's functional approach rather than forcing ORM mental model makes library more intuitive. The content particularly benefits developers building APIs or background jobs accessing databases outside Phoenix web context, learning Ecto independent of framework integration, along with teams requiring complex queries joining multiple tables or aggregating data where hand-written SQL proves necessary. Anyone frustrated by N+1 query problems or mysterious Ecto association preloading behavior will appreciate systematic explanation of how Ecto loads related data and when to use joins versus preloads.

## Practical Applications

Readers will learn to define schemas mapping Elixir structs to database tables specifying fields, types, and default values, implement associations through belongs_to, has_many, has_one, and many_to_many macros expressing relationships declaratively, and create changesets validating user input and type casting before attempting database writes catching errors early. The book demonstrates building queries using Ecto.Query DSL composing where clauses, ordering results, limiting rows, and selecting specific fields creating flexible query pipelines, joining associated tables through join or implicit joins in where clauses optimizing queries avoiding N+1 problems, and using subqueries or common table expressions for complex analytical queries. Practical examples cover inserting, updating, and deleting records through changesets providing validation and constraints, handling form data using cast validating and converting string inputs to appropriate types, and implementing custom validations beyond built-in length or format validators. Advanced topics include using Ecto.Multi for executing multiple database operations within single transaction rolling back all on any failure, implementing polymorphic associations where records can belong to multiple parent types, and creating dynamic queries building where clauses conditionally based on search parameters. The book provides migration strategies for evolving schemas adding columns, indexes, or constraints reversibly, handling data migrations transforming existing records during schema changes, and managing migration rollback ensuring development and production databases stay synchronized. Performance optimization covers understanding query plans using EXPLAIN, adding database indexes improving query performance on filtered or joined columns, and using select to load only needed fields reducing data transfer. Testing strategies include using sandbox mode isolating test database changes in transactions rolled back after tests, creating test factories generating valid test data, and mocking repository calls for unit testing business logic independent of database.
