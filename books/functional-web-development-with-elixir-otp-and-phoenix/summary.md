# Functional Web Development with Elixir, OTP, and Phoenix

## Key Concepts

This book teaches building web applications by separating business logic into pure Elixir modules from web concerns handled by Phoenix, using OTP behaviors for state management and process supervision creating robust fault-tolerant systems. The core philosophy treats Phoenix as presentation layer over application core where domain logic lives in plain Elixir leveraging functional programming principles like immutability and pure functions, with OTP providing battle-tested patterns for concurrent stateful processes. Key concepts include implementing game logic or business rules as pure functions easily testable without framework dependencies, using GenServer for managing application state through process mailboxes and callbacks, and applying supervision trees ensuring system resilience through automatic process restart on failure. The book demonstrates that functional programming's emphasis on immutability and explicit state management simplifies reasoning about concurrent systems compared to object-oriented mutable state shared across threads.

## Who Should Read It and Why

This book targets Elixir developers comfortable with Phoenix basics wanting to structure applications beyond CRUD operations, programmers learning functional programming seeking practical guidance applying concepts to real applications rather than abstract exercises, and developers building stateful real-time applications like games, chat systems, or dashboards where OTP shines. Those who treat Phoenix like Rails putting all logic in controllers or contexts will discover benefits of extracting pure domain logic separate from web framework, enabling testing, reuse, and reasoning independent of HTTP concerns. The content particularly benefits developers building applications requiring in-memory state beyond database persistence like game state, user sessions, or cached computations where GenServer processes provide isolated mutable state in otherwise immutable language. Anyone struggling with Phoenix LiveView or Channels state management will appreciate OTP foundations explaining how processes work and how to structure them appropriately.

## Practical Applications

Readers will learn to implement domain logic as pure modules with functions transforming data without side effects, design APIs using pattern matching for multiple function clauses handling different inputs elegantly, and test business logic thoroughly without starting web server or database through pure function simplicity. The book demonstrates wrapping stateful logic in GenServer defining callbacks like init, handle_call, and handle_cast managing process state through messages, supervising processes defining strategies like one-for-one or rest-for-one controlling restart behavior when processes crash, and organizing supervision trees hierarchically isolating failures preventing cascading crashes. Practical examples cover building real-time features using Phoenix Channels or LiveView backed by GenServer processes maintaining game state, implementing presence tracking showing online users through distributed process registry, and creating background job processors using GenServer and supervisor ensuring tasks complete despite failures. Advanced patterns include using Agent for simple state management wrapping GenServer when complex callbacks aren't needed, implementing ETS tables for fast concurrent read access to shared data, and applying Registry for process naming and discovery enabling communication between processes. The book provides integration strategies connecting OTP-based core to Phoenix through controllers invoking GenServer calls, LiveView mounting GenServer state into socket assigns, and channels broadcasting GenServer state changes to connected clients. Testing approaches cover unit testing pure functions verifying business logic correctness, testing GenServer using synchronous calls ensuring correct state transitions, and integration testing full workflows from HTTP request through business logic to response. Production considerations include monitoring process mailbox sizes identifying bottlenecks, implementing back pressure preventing system overload, and using telemetry for metrics collection understanding system behavior under load.
