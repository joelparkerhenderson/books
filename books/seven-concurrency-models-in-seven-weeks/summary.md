# Seven Concurrency Models in Seven Weeks

## Key Concepts

This book surveys seven distinct approaches to concurrent and parallel programming, demonstrating that different concurrency models suit different problems beyond traditional threads and locks. The covered models include shared-memory threading with synchronization primitives, functional programming with immutable data structures eliminating race conditions, the actor model isolating mutable state in independent entities communicating through messages, and Communicating Sequential Processes using channels for coordination. Additional paradigms include data parallelism leveraging GPUs for massive computational throughput, the Lambda Architecture combining batch and stream processing for big data, and the Reactive programming model handling asynchronous event streams. The book emphasizes that each model makes different trade-offs between safety, performance, and complexity, requiring developers to expand their concurrency toolkit beyond familiar patterns.

## Who Should Read It and Why

This book targets developers comfortable with basic multithreading but struggling to reason about complex concurrent systems, wanting exposure to alternative approaches that simplify particular problem classes. Programmers who have encountered race conditions, deadlocks, or other concurrency bugs in traditional thread-based code will discover models like actors or CSP that eliminate entire categories of these issues through design. The content particularly benefits those working on systems requiring high throughput or low latency, learning when to apply each model whether building responsive user interfaces, processing data streams, or maximizing multi-core CPU utilization. Engineers comfortable in one paradigm like object-oriented programming will find their thinking expanded by functional approaches to concurrency, while those familiar with single-machine concurrency will discover distributed system patterns through actor models and reactive streams.

## Practical Applications

Readers will learn to identify when shared-memory threading with locks and semaphores fits naturally versus when it creates unnecessary complexity, implement actor systems using frameworks like Akka for building fault-tolerant distributed applications, and apply CSP patterns with Go's goroutines and channels for coordinating concurrent operations. The book demonstrates writing pure functional concurrent code in Clojure using persistent data structures, leveraging OpenCL for data-parallel GPU computation on large datasets, and building event-driven systems with reactive extensions handling asynchronous data streams. Practical examples cover implementing producer-consumer patterns across different models, building parallel map-reduce computations, and creating responsive applications that remain interactive during background processing. Advanced topics include combining models like using actors for coordination while employing functional techniques within actor implementations, understanding when immutability trades memory for safety appropriately, and applying the Lambda Architecture for systems processing both historical and real-time data. The book provides hands-on exercises in each model's representative language or framework, building intuition for selecting appropriate concurrency approaches based on problem characteristics rather than defaulting to familiar but potentially inappropriate patterns.
