# Ash Framework

## Key Concepts

This book introduces Ash as declarative domain-modeling framework for Elixir applications, providing structure for defining business logic through resources, actions, attributes, and relationships rather than scattered controller and model code. The core philosophy treats domain models as first-class declarations where you specify what your application does through resource definitions capturing entities, their attributes, lifecycle actions, and business rules, with Ash generating implementation details like database queries, validations, and authorization checks. Key concepts include resources as central abstraction representing domain entities with defined attributes, actions like create, read, update, destroy plus custom actions encapsulating business operations, and relationships between resources expressed declaratively with belongs_to, has_many, and has_one associations. The book covers authorization policies defining fine-grained access control through expressions evaluated against request context, calculations for derived attributes computed from other fields, and aggregates for statistics across relationships like counting related records or summing values.

## Who Should Read It and Why

This book targets Elixir developers building business applications who want structure beyond barebones Phoenix contexts, teams finding domain logic scattered across controllers needing centralized business rules, and developers attracted to declarative programming wanting database-agnostic abstractions over writing SQL or Ecto queries directly. Those frustrated by repetitive controller boilerplate validating inputs, checking permissions, and querying databases will discover Ash consolidates these concerns into resource definitions reducing code duplication. The content particularly benefits teams building CRUD-heavy applications where Ash's conventions accelerate development, along with developers wanting GraphQL or JSON:API endpoints generated automatically from resource definitions without hand-coding resolvers or serializers. Anyone who has struggled keeping authorization logic consistent across API, web, and background job contexts will appreciate Ash's authorization policies enforced uniformly regardless of invocation method.

## Practical Applications

Readers will learn to define resources specifying attributes with types and constraints, declaring actions including validations and changes executed during lifecycle events, and establishing relationships enabling navigation between related entities through preloading or queries. The book demonstrates implementing authorization through policies expressing who can perform actions under what conditions using expressions checking user roles, resource ownership, or custom business rules, calculating derived attributes like full names from first and last names or ages from birthdates, and aggregating related data like post counts per user or average ratings per product. Practical examples cover building APIs using AshGraphQL for GraphQL endpoints with customizable queries and mutations or AshJsonApi for JSON:API-compliant REST endpoints, creating Phoenix LiveView interfaces leveraging Ash for forms and data loading, and implementing business logic through custom actions encapsulating multi-step operations or side effects. Advanced topics include using multitenancy isolating data by organization or account through tenant-aware queries, implementing soft deletes through attribute-based filtering, and applying embedded resources for structured attributes like addresses within parent resources. The book provides integration patterns connecting Ash to PostgreSQL through AshPostgres data layer, defining indexes and database-specific features, and using Ash with existing Ecto schemas when migrating gradually from traditional Phoenix applications. Testing strategies cover using Ash.Seed for test data generation, testing resources and actions independently from persistence layers, and validating authorization policies ensuring security rules work correctly. Production considerations include querying performance through loading strategies and SQL EXPLAIN analysis, caching frequently accessed data, and monitoring resource usage identifying bottlenecks in declarative definitions.
