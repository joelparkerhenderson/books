# Practical Microservices

## Key Concepts

This book teaches building microservices architectures by developing complete video streaming application, demonstrating how to decompose monolithic applications into independent services communicating through message passing for scalability and resilience. The core philosophy emphasizes event-driven architecture where services communicate by publishing and consuming domain events rather than direct RPC calls, creating loose coupling enabling services to evolve independently while maintaining system coherence through shared event stream. Key patterns include event sourcing storing all state changes as immutable events creating audit trail and enabling time travel, CQRS separating read and write models optimizing each independently, and using message store as central nervous system where services publish events others consume asynchronously. The book covers practical considerations like service boundaries determined by business capabilities rather than technical layers, autonomous deployments enabling teams to release services independently, and handling eventual consistency where different services temporarily have inconsistent views of data.

## Who Should Read It and Why

This book targets developers building or maintaining monolithic applications experiencing scaling bottlenecks or deployment friction wanting to understand microservices beyond theoretical architectural discussions, architects evaluating whether microservices suit their organization's needs with realistic assessment of complexity trade-offs, and teams practicing microservices but struggling with operational burden or service coordination seeking proven patterns. Those who attempted microservices and created distributed monolith with services calling each other synchronously will discover event-driven messaging creating true independence. The content particularly benefits organizations where different teams own different features finding monolithic deployment causing coordination overhead and deployment conflicts, learning how service autonomy enables parallel development and deployment. Anyone confused by contradictory microservices advice will appreciate pragmatic approach building real system showing what works versus theoretical ideals difficult to implement.

## Practical Applications

Readers will learn to identify service boundaries using domain-driven design concepts like bounded contexts and aggregates ensuring services have clear responsibilities, implement message passing using message store where services append events to streams and read events through subscriptions, and handle eventual consistency designing UIs that acknowledge asynchronous processing rather than pretending operations complete synchronously. The book demonstrates building event-sourced aggregates where entity state derives from applying events rather than storing current state directly, implementing projections consuming event streams to build read models optimized for queries, and using sagas coordinating long-running transactions across services through sequences of local transactions compensating for failures. Practical examples cover building video transcoding service processing uploaded videos asynchronously, implementing view counting service subscribing to video-viewed events updating counts, and creating recommendation service analyzing viewing patterns across users. Advanced patterns include implementing outbox pattern ensuring reliable message publishing by writing events to database within transaction then publishing separately, using correlation IDs tracking requests across services for distributed tracing, and applying circuit breakers preventing cascading failures when dependencies become unavailable. The book provides deployment strategies using containers with Docker ensuring consistent environments, orchestration through Kubernetes managing service lifecycles and scaling, and monitoring distributed systems through centralized logging and metrics aggregation understanding system behavior across services. Testing approaches cover unit testing pure domain logic, integration testing message handlers ensuring correct event processing, and end-to-end testing entire workflows though limiting these due to flakiness and maintenance cost.
