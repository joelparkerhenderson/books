# Programming Erlang

## Key Concepts

This book introduces Erlang as concurrent functional programming language designed for building fault-tolerant distributed systems, originally created for telecom switches requiring extreme reliability and hot code swapping without downtime. The core actor model treats processes as isolated units communicating through asynchronous message passing eliminating shared state and locks, with lightweight processes numbering millions per machine managed by BEAM virtual machine's efficient scheduler. Key concepts include let-it-crash philosophy where processes fail fast while supervisor processes restart them automatically, pattern matching in receive blocks handling different message types elegantly, and distribution transparency where sending messages to remote processes uses same syntax as local messaging. The book covers OTP (Open Telecom Platform) framework providing battle-tested abstractions like gen_server for request-response servers, supervisors implementing recovery strategies, and applications packaging deployable systems, with these components composing into fault-tolerant systems proven in production across decades.

## Who Should Read It and Why

This book targets developers building systems requiring high availability like messaging platforms, real-time games, or financial systems where downtime costs money, along with programmers curious about functional programming applied to practical concurrent systems rather than academic exercises. Those struggling with thread synchronization bugs, race conditions, or deadlocks in traditional concurrent programming will discover Erlang's message-passing model eliminates entire categories of these problems through design. The content particularly benefits developers building distributed systems learning from Erlang's decades of battle-tested patterns for handling network partitions, node failures, and system upgrades without downtime. Anyone interested in actor model after hearing about Akka or Elixir will appreciate learning from original implementation that pioneered these concepts, while system programmers wanting alternatives to C or Java for building robust servers will find Erlang's focus on reliability through isolation and supervision compelling.

## Practical Applications

Readers will learn to spawn processes creating isolated units of computation executing concurrently, send and receive messages using Erlang's mailbox pattern where processes check messages selectively through pattern matching, and link processes creating supervision relationships where one process monitors others restarting them on failure. The book demonstrates implementing client-server patterns using gen_server behavior providing structured request-response handling with state management, building supervision trees where supervisors restart failed children according to strategies like one-for-one or one-for-all, and creating applications bundling related processes into deployable units. Practical examples cover building chat servers handling thousands of concurrent connections using lightweight processes, implementing distributed key-value stores using distributed Erlang where nodes communicate transparently, and creating hot code swapping updating running systems without stopping them. Advanced topics include using ETS and Mnesia for in-memory and distributed databases respectively, implementing protocols using gen_tcp for custom network communication, and debugging distributed systems using tools like observer visualizing process hierarchies and message passing. The book provides guidance on error handling through philosophy of letting it crash rather than defensive programming, performance optimization understanding process scheduling and message passing costs, and deployment strategies using releases creating self-contained artifacts including BEAM runtime. Production considerations cover monitoring systems using tools like recon, load testing to find limits using tools like basho_bench, and operational practices including hot upgrades and distributed system debugging.
